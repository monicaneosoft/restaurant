{
  "version": 3,
  "file": "zxing-ngx-scanner.umd.min.js",
  "sources": [
    "ng://@zxing/ngx-scanner/node_modules/tslib/tslib.es6.js",
    "ng://@zxing/ngx-scanner/out/app/modules/zxing-scanner/browser-code-reader.ts",
    "ng://@zxing/ngx-scanner/out/app/modules/zxing-scanner/browser-multi-format-reader.ts",
    "ng://@zxing/ngx-scanner/out/app/modules/zxing-scanner/zxing-scanner.component.ts",
    "ng://@zxing/ngx-scanner/out/app/modules/zxing-scanner/zxing-scanner.module.ts"
  ],
  "sourcesContent": [
    "/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)\r\n            t[p[i]] = s[p[i]];\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n",
    "/// <reference path=\"./image-capture.d.ts\" />\n\nimport {\n  BinaryBitmap,\n  ChecksumException,\n  Exception,\n  FormatException,\n  HTMLCanvasElementLuminanceSource,\n  HybridBinarizer,\n  NotFoundException,\n  Reader,\n  Result,\n} from '@zxing/library';\n\nimport {\n  BehaviorSubject,\n  Observable,\n  Subscriber,\n  Subscription\n} from 'rxjs';\n\nimport { catchError } from 'rxjs/operators';\n\n/**\n * Based on zxing-typescript BrowserCodeReader\n */\nexport class BrowserCodeReader {\n\n  /**\n   * The HTML video element, used to display the camera stream.\n   */\n  private videoElement: HTMLVideoElement;\n  /**\n   * Should contain the current registered listener for video play-ended,\n   * used to unregister that listener when needed.\n   */\n  private videoPlayEndedEventListener: EventListener;\n  /**\n   * Should contain the current registered listener for video playing,\n   * used to unregister that listener when needed.\n   */\n  private videoPlayingEventListener: EventListener;\n  /**\n   * Should contain the current registered listener for video loaded-metadata,\n   * used to unregister that listener when needed.\n   */\n  private videoLoadedMetadataEventListener: EventListener;\n\n  /**\n   * The HTML image element, used as a fallback for the video element when decoding.\n   */\n  private imageElement: HTMLImageElement;\n  /**\n   * Should contain the current registered listener for image loading,\n   * used to unregister that listener when needed.\n   */\n  private imageLoadedEventListener: EventListener;\n\n  /**\n   * The HTML canvas element, used to draw the video or image's frame for decoding.\n   */\n  private canvasElement: HTMLCanvasElement;\n  /**\n   * The HTML canvas element context.\n   */\n  private canvasElementContext: CanvasRenderingContext2D;\n\n  /**\n   * Used to control the decoding stream when it's open.\n   */\n  private decodingStream: Subscription;\n\n  /**\n   * The stream output from camera.\n   */\n  private stream: MediaStream;\n  /**\n   * The track from camera.\n   */\n  private track: MediaStreamTrack;\n  /**\n   * Shows if torch is available on the camera.\n   */\n  private torchCompatible = new BehaviorSubject<boolean>(false);\n\n  /**\n   * The device id of the current media device.\n   */\n  private deviceId: string;\n\n  /**\n   * Constructor for dependency injection.\n   *\n   * @param reader The barcode reader to be used to decode the stream.\n   * @param timeBetweenScans The scan throttling in milliseconds.\n   */\n  public constructor(protected readonly reader: Reader, private timeBetweenScans: number = 500) { }\n\n  /**\n   * Starts the decoding from the current or a new video element.\n   *\n   * @param callbackFn The callback to be executed after every scan attempt\n   * @param deviceId The device's to be used Id\n   * @param videoElement A new video element\n   *\n   * @todo Return Promise<Result>\n   */\n  public async decodeFromInputVideoDevice(\n    callbackFn?: (result: Result) => any,\n    deviceId?: string,\n    videoElement?: HTMLVideoElement\n  ): Promise<void> {\n\n    this.reset();\n\n    this.prepareVideoElement(videoElement);\n\n    // Keeps the deviceId between scanner resets.\n    if (typeof deviceId !== 'undefined') {\n      this.deviceId = deviceId;\n    }\n\n    const video = typeof deviceId === 'undefined'\n      ? { facingMode: { exact: 'environment' } }\n      : { deviceId: { exact: deviceId } };\n\n    const constraints: MediaStreamConstraints = {\n      audio: false,\n      video\n    };\n\n    if (typeof navigator === 'undefined') {\n      return;\n    }\n\n    try {\n      const stream = await navigator\n        .mediaDevices\n        .getUserMedia(constraints);\n\n      this.startDecodeFromStream(stream, callbackFn);\n\n    } catch (err) {\n      /* handle the error, or not */\n      console.error(err);\n    }\n  }\n\n  /**\n   * Sets the new stream and request a new decoding-with-delay.\n   *\n   * @param stream The stream to be shown in the video element.\n   * @param callbackFn A callback for the decode method.\n   *\n   * @todo Return Promise<Result>\n   */\n  private startDecodeFromStream(stream: MediaStream, callbackFn?: (result: Result) => any): void {\n    this.stream = stream;\n    this.checkTorchCompatibility(this.stream);\n    this.bindVideoSrc(this.videoElement, this.stream);\n    this.bindEvents(this.videoElement, callbackFn);\n  }\n\n  /**\n   * Defines what the videoElement src will be.\n   *\n   * @param videoElement\n   * @param stream\n   */\n  public bindVideoSrc(videoElement: HTMLVideoElement, stream: MediaStream): void {\n    // Older browsers may not have `srcObject`\n    try {\n      // @NOTE Throws Exception if interrupted by a new loaded request\n      videoElement.srcObject = stream;\n    } catch (err) {\n      // @NOTE Avoid using this in new browsers, as it is going away.\n      videoElement.src = window.URL.createObjectURL(stream);\n    }\n  }\n\n  /**\n   * Unbinds a HTML video src property.\n   *\n   * @param videoElement\n   */\n  public unbindVideoSrc(videoElement: HTMLVideoElement): void {\n    try {\n      videoElement.srcObject = null;\n    } catch (err) {\n      videoElement.src = '';\n    }\n  }\n\n  /**\n   * Binds listeners and callbacks to the videoElement.\n   *\n   * @param videoElement\n   * @param callbackFn\n   */\n  private bindEvents(videoElement: HTMLVideoElement, callbackFn?: (result: Result) => any): void {\n\n    if (typeof callbackFn !== 'undefined') {\n      this.videoPlayingEventListener = () => this.decodingStream = this.decodeWithDelay(this.timeBetweenScans)\n        .pipe(catchError((e, x) => this.handleDecodeStreamError(e, x)))\n        .subscribe((x: Result) => callbackFn(x));\n    }\n\n    videoElement.addEventListener('playing', this.videoPlayingEventListener);\n\n    this.videoLoadedMetadataEventListener = () => videoElement.play();\n\n    videoElement.addEventListener('loadedmetadata', this.videoLoadedMetadataEventListener);\n  }\n\n  /**\n   * Checks if the stream supports torch control.\n   *\n   * @param stream The media stream used to check.\n   */\n  private async checkTorchCompatibility(stream: MediaStream): Promise<void> {\n    try {\n      this.track = stream.getVideoTracks()[0];\n      const imageCapture = new ImageCapture(this.track);\n      const capabilities = await imageCapture.getPhotoCapabilities();\n      const compatible = !!capabilities.torch || ('fillLightMode' in capabilities && capabilities.fillLightMode.length !== 0);\n      this.torchCompatible.next(compatible);\n    } catch (err) {\n      this.torchCompatible.next(false);\n    }\n  }\n\n  /**\n   * Enables and disables the device torch.\n   */\n  public setTorch(on: boolean): void {\n    if (!this.torchCompatible.value) {\n      return;\n    }\n    if (on) {\n      this.track.applyConstraints({\n        advanced: [<any>{ torch: true }]\n      });\n    } else {\n      this.restart();\n    }\n  }\n\n  /**\n   * Observable that says if there's a torch available for the current device.\n   */\n  public get torchAvailable(): Observable<boolean> {\n    return this.torchCompatible.asObservable();\n  }\n\n  /**\n   * Sets a HTMLVideoElement for scanning or creates a new one.\n   *\n   * @param videoElement The HTMLVideoElement to be set.\n   */\n  private prepareVideoElement(videoElement?: HTMLVideoElement): void {\n\n    if (!videoElement && typeof document !== 'undefined') {\n      videoElement = document.createElement('video');\n      videoElement.width = 200;\n      videoElement.height = 200;\n    }\n\n    this.videoElement = videoElement;\n  }\n\n  /**\n   * Opens a decoding stream.\n   */\n  private decodeWithDelay(delay: number = 500): Observable<Result> {\n    // The decoding stream.\n    return Observable.create((observer: Subscriber<Result>) => {\n      // Creates on Subscribe.\n      const intervalId = setInterval(() => {\n        try {\n          observer.next(this.decode());\n        } catch (err) {\n          observer.error(err);\n        }\n      }, delay);\n      // Destroys on Unsubscribe.\n      return () => clearInterval(intervalId);\n    });\n  }\n\n  /**\n   * Gets the BinaryBitmap for ya! (and decodes it)\n   */\n  private decode(): Result {\n\n    // get binary bitmap for decode function\n    const binaryBitmap = this.createBinaryBitmap(this.videoElement || this.imageElement);\n\n    return this.decodeBitmap(binaryBitmap);\n  }\n\n  /**\n   * Call the encapsulated readers decode\n   */\n  protected decodeBitmap(binaryBitmap: BinaryBitmap): Result {\n    return this.reader.decode(binaryBitmap);\n  }\n\n  /**\n   * Administra um erro gerado durante o decode stream.\n   */\n  private handleDecodeStreamError(err: Exception, caught: Observable<Result>): Observable<Result> {\n\n    if (\n      // scan Failure - found nothing, no error\n      err instanceof NotFoundException ||\n      // scan Error - found the QR but got error on decoding\n      err instanceof ChecksumException ||\n      err instanceof FormatException\n    ) {\n      return caught;\n    }\n\n    throw err;\n  }\n\n  /**\n   * Creates a binaryBitmap based in some image source.\n   *\n   * @param mediaElement HTML element containing drawable image source.\n   */\n  private createBinaryBitmap(mediaElement: HTMLVideoElement | HTMLImageElement): BinaryBitmap {\n\n    if (undefined === this.canvasElementContext) {\n      this.prepareCaptureCanvas();\n    }\n\n    this.canvasElementContext.drawImage(mediaElement, 0, 0);\n\n    const luminanceSource = new HTMLCanvasElementLuminanceSource(this.canvasElement);\n    const hybridBinarizer = new HybridBinarizer(luminanceSource);\n\n    return new BinaryBitmap(hybridBinarizer);\n  }\n\n  /**\n   * ðŸ–Œ Prepares the canvas for capture and scan frames.\n   */\n  private prepareCaptureCanvas(): void {\n\n    if (typeof document === 'undefined') {\n\n      this.canvasElement = undefined;\n      this.canvasElementContext = undefined;\n\n      return;\n    }\n\n    const canvasElement = document.createElement('canvas');\n\n    let width: number;\n    let height: number;\n\n    if (typeof this.videoElement !== 'undefined') {\n      width = this.videoElement.videoWidth;\n      height = this.videoElement.videoHeight;\n    }\n\n    if (typeof this.imageElement !== 'undefined') {\n      width = this.imageElement.naturalWidth || this.imageElement.width;\n      height = this.imageElement.naturalHeight || this.imageElement.height;\n    }\n\n    canvasElement.style.width = width + 'px';\n    canvasElement.style.height = height + 'px';\n    canvasElement.width = width;\n    canvasElement.height = height;\n\n    this.canvasElement = canvasElement;\n    this.canvasElementContext = canvasElement.getContext('2d');\n  }\n\n  /**\n   * Stops the continuous scan and cleans the stream.\n   */\n  private stop(): void {\n\n    if (this.decodingStream) {\n      this.decodingStream.unsubscribe();\n    }\n\n    if (this.stream) {\n      this.stream.getVideoTracks().forEach(t => t.stop());\n      this.stream = undefined;\n    }\n\n  }\n\n  /**\n   * Resets the scanner and it's configurations.\n   */\n  public reset(): void {\n\n    // stops the camera, preview and scan ðŸ”´\n\n    this.stop();\n\n    if (this.videoElement) {\n\n      // first gives freedon to the element ðŸ•Š\n\n      if (typeof this.videoPlayEndedEventListener !== 'undefined') {\n        this.videoElement.removeEventListener('ended', this.videoPlayEndedEventListener);\n      }\n\n      if (typeof this.videoPlayingEventListener !== 'undefined') {\n        this.videoElement.removeEventListener('playing', this.videoPlayingEventListener);\n      }\n\n      if (typeof this.videoLoadedMetadataEventListener !== 'undefined') {\n        this.videoElement.removeEventListener('loadedmetadata', this.videoLoadedMetadataEventListener);\n      }\n\n      // then forgets about that element ðŸ˜¢\n\n      this.unbindVideoSrc(this.videoElement);\n\n      this.videoElement.removeAttribute('src');\n      this.videoElement = undefined;\n    }\n\n    if (this.imageElement) {\n\n      // first gives freedon to the element ðŸ•Š\n\n      if (undefined !== this.videoPlayEndedEventListener) {\n        this.imageElement.removeEventListener('load', this.imageLoadedEventListener);\n      }\n\n      // then forgets about that element ðŸ˜¢\n\n      this.imageElement.src = undefined;\n      this.imageElement.removeAttribute('src');\n      this.imageElement = undefined;\n    }\n\n    // cleans canvas references ðŸ–Œ\n\n    this.canvasElementContext = undefined;\n    this.canvasElement = undefined;\n  }\n\n  /**\n   * Restarts the scanner.\n   */\n  private restart(): void {\n    // reset\n    // start\n    this.decodeFromInputVideoDevice(undefined, this.deviceId, this.videoElement);\n  }\n}\n",
    "import { MultiFormatReader, DecodeHintType, BinaryBitmap, Result } from '@zxing/library';\n\nimport { BrowserCodeReader } from './browser-code-reader';\n\nexport class BrowserMultiFormatReader extends BrowserCodeReader {\n\n  protected readonly reader: MultiFormatReader;\n\n  public constructor(\n    hints: Map<DecodeHintType, any> = null,\n    timeBetweenScansMillis: number = 500\n  ) {\n    const reader = new MultiFormatReader();\n    reader.setHints(hints);\n    super(reader, timeBetweenScansMillis);\n  }\n\n  /**\n   * Overwrite decodeBitmap to call decodeWithState, which will pay\n   * attention to the hints set in the constructor function\n   */\n  protected decodeBitmap(binaryBitmap: BinaryBitmap): Result {\n    return this.reader.decodeWithState(binaryBitmap);\n  }\n}\n",
    "import {\n  AfterViewInit,\n  ChangeDetectionStrategy,\n  Component,\n  ElementRef,\n  EventEmitter,\n  Input,\n  OnChanges,\n  OnDestroy,\n  Output,\n  SimpleChanges,\n  ViewChild\n} from '@angular/core';\n\nimport { Result, DecodeHintType, BarcodeFormat } from '@zxing/library';\n\nimport { BrowserMultiFormatReader } from './browser-multi-format-reader';\n\n@Component({\n  // tslint:disable-next-line:component-selector\n  selector: 'zxing-scanner',\n  template: `<video #preview [style.object-fit]=\"previewFitMode\">\n  <p>\n    Your browser does not support this feature, please try to upgrade it.\n  </p>\n  <p>\n    Seu navegador nÃ£o suporta este recurso, por favor tente atualizÃ¡-lo.\n  </p>\n</video>\n`,\n  styles: [`:host{display:block}video{width:100%;height:auto;-o-object-fit:contain;object-fit:contain}`],\n  changeDetection: ChangeDetectionStrategy.OnPush\n})\nexport class ZXingScannerComponent implements AfterViewInit, OnDestroy, OnChanges {\n\n  /**\n   * Supported Hints map.\n   */\n  private _hints: Map<DecodeHintType, any>;\n\n  /**\n   * The ZXing code reader.\n   */\n  private codeReader: BrowserMultiFormatReader;\n\n  /**\n   * Has `navigator` access.\n   */\n  private hasNavigator: boolean;\n\n  /**\n   * Says if some native API is supported.\n   */\n  private isMediaDevicesSuported: boolean;\n\n  /**\n   * Says if some native API is supported.\n   */\n  private isEnumerateDevicesSuported: boolean;\n\n  /**\n   * List of enable video-input devices.\n   */\n  private videoInputDevices: MediaDeviceInfo[];\n\n  /**\n   * The current device used to scan things.\n   */\n  private videoInputDevice: MediaDeviceInfo;\n\n  /**\n   * If the user-agent allowed the use of the camera or not.\n   */\n  private hasPermission: boolean;\n\n  /**\n   * If any media device were found.\n   */\n  private set _hasDevices(hasDevice: boolean) {\n    this.hasDevices.next(hasDevice);\n  }\n\n  /**\n   * Reference to the preview element, should be the `video` tag.\n   */\n  @ViewChild('preview')\n  previewElemRef: ElementRef;\n\n  /**\n   * Allow start scan or not.\n   */\n  @Input()\n  scannerEnabled = true;\n\n  /**\n   * The device that should be used to scan things.\n   */\n  @Input()\n  device: MediaDeviceInfo;\n\n  /**\n   * Enable or disable autofocus of the camera (might have an impact on performance)\n   */\n  @Input()\n  autofocusEnabled = true;\n\n  /**\n   * How the preview element shoud be fit inside the :host container.\n   */\n  @Input()\n  previewFitMode: 'fill' | 'contain' | 'cover' | 'scale-down' | 'none' = 'cover';\n\n  /**\n   * Emitts events when the torch compatibility is changed.\n   */\n  @Output()\n  torchCompatible = new EventEmitter<boolean>();\n\n  /**\n   * Emitts events when a scan is successful performed, will inject the string value of the QR-code to the callback.\n   */\n  @Output()\n  scanSuccess = new EventEmitter<string>();\n\n  /**\n   * Emitts events when a scan fails without errors, usefull to know how much scan tries where made.\n   */\n  @Output()\n  scanFailure = new EventEmitter<void>();\n\n  /**\n   * Emitts events when a scan throws some error, will inject the error to the callback.\n   */\n  @Output()\n  scanError = new EventEmitter<Error>();\n\n  /**\n   * Emitts events when a scan is performed, will inject the Result value of the QR-code scan (if available) to the callback.\n   */\n  @Output()\n  scanComplete = new EventEmitter<Result>();\n\n  /**\n   * Emitts events when no cameras are found, will inject an exception (if available) to the callback.\n   */\n  @Output()\n  camerasFound = new EventEmitter<MediaDeviceInfo[]>();\n\n  /**\n   * Emitts events when no cameras are found, will inject an exception (if available) to the callback.\n   */\n  @Output()\n  camerasNotFound = new EventEmitter<any>();\n\n  /**\n   * Emitts events when the users answers for permission.\n   */\n  @Output()\n  permissionResponse = new EventEmitter<boolean>();\n\n  /**\n   * Emitts events when has devices status is update.\n   */\n  @Output()\n  hasDevices = new EventEmitter<boolean>();\n\n  /**\n   * Returns all the registered formats.\n   */\n  get formats(): BarcodeFormat[] {\n    return this.hints.get(DecodeHintType.POSSIBLE_FORMATS);\n  }\n\n  /**\n   * Registers formats the scanner should support.\n   *\n   * @param input BarcodeFormat or case-insensitive string array.\n   */\n  @Input()\n  set formats(input: BarcodeFormat[]) {\n\n    if (typeof input === 'string') {\n      throw new Error('Invalid formats, make sure the [formats] input is a binding.');\n    }\n\n    // formats may be set from html template as BarcodeFormat or string array\n    const formats = input.map(f => this.getBarcodeFormat(f));\n\n    // updates the hints\n    this.hints.set(DecodeHintType.POSSIBLE_FORMATS, formats);\n\n    // new instance with new hints.\n    this.refreshCodeReader();\n  }\n\n  /**\n   * Returns all the registered hints.\n   */\n  get hints() {\n    return this._hints;\n  }\n\n  /**\n   * Allow start scan or not.\n   */\n  @Input()\n  set torch(on: boolean) {\n    this.codeReader.setTorch(on);\n  }\n\n  /**\n   * If is `tryHarder` enabled.\n   */\n  get tryHarder(): boolean {\n    return this.hints.get(DecodeHintType.TRY_HARDER);\n  }\n\n  /**\n   * Enable/disable tryHarder hint.\n   */\n  @Input()\n  set tryHarder(enable: boolean) {\n    if (enable) {\n      this.hints.set(DecodeHintType.TRY_HARDER, true);\n    } else {\n      this.hints.delete(DecodeHintType.TRY_HARDER);\n    }\n\n    // new instance with new hints.\n    this.refreshCodeReader();\n  }\n\n  /**\n   * Constructor to build the object and do some DI.\n   */\n  constructor() {\n    this._hints = new Map<DecodeHintType, any>();\n    this.hasNavigator = typeof navigator !== 'undefined';\n    this.isMediaDevicesSuported = this.hasNavigator && !!navigator.mediaDevices;\n    this.isEnumerateDevicesSuported = !!(this.isMediaDevicesSuported && navigator.mediaDevices.enumerateDevices);\n\n    // will start codeReader if needed.\n    this.formats = [BarcodeFormat.QR_CODE];\n  }\n\n  /**\n   * Manages the bindinded property changes.\n   * @param changes\n   */\n  ngOnChanges(changes: SimpleChanges): void {\n\n    if (changes.scannerEnabled) {\n      if (!this.scannerEnabled) {\n        this.resetCodeReader();\n      } else if (this.videoInputDevice) {\n        this.scan(this.videoInputDevice.deviceId);\n      }\n    }\n\n    if (changes.device) {\n      if (this.device) {\n        this.changeDevice(this.device);\n      } else {\n        console.warn('zxing-scanner', 'device', 'Unselected device.');\n        this.resetCodeReader();\n      }\n    }\n  }\n\n  /**\n   * Executed after the view initialization.\n   */\n  async ngAfterViewInit(): Promise<void> {\n\n    // Chrome 63 fix\n    if (!this.previewElemRef) {\n      console.warn('zxing-scanner', 'Preview element not found!');\n      return;\n    }\n\n    // iOS 11 Fix\n    this.previewElemRef.nativeElement.setAttribute('autoplay', false);\n    this.previewElemRef.nativeElement.setAttribute('muted', true);\n    this.previewElemRef.nativeElement.setAttribute('playsinline', true);\n    this.previewElemRef.nativeElement.setAttribute('autofocus', this.autofocusEnabled);\n\n    // Asks for permission before enumerating devices so it can get all the device's info\n    const hasPermission = await this.askForPermission();\n\n    // gets and enumerates all video devices\n    this.enumarateVideoDevices().then((videoInputDevices: MediaDeviceInfo[]) => {\n\n      if (videoInputDevices && videoInputDevices.length > 0) {\n        this._hasDevices = true;\n        this.camerasFound.next(videoInputDevices);\n      } else {\n        this._hasDevices = false;\n        this.camerasNotFound.next();\n      }\n\n    });\n\n    // There's nothin' to do anymore if we don't have permissions.\n    if (hasPermission !== true) {\n      return;\n    }\n\n    this.startScan(this.videoInputDevice);\n\n    this.codeReader.torchAvailable.subscribe((value: boolean) => {\n      this.torchCompatible.emit(value);\n    });\n  }\n\n  /**\n   * Executes some actions before destroy the component.\n   */\n  ngOnDestroy(): void {\n    this.resetCodeReader();\n  }\n\n  /**\n   * Properly changes the current target device.\n   *\n   * @param device\n   */\n  changeDevice(device: MediaDeviceInfo): void {\n    this.resetCodeReader();\n    this.videoInputDevice = device;\n    this.startScan(device);\n  }\n\n  /**\n   * Properly changes the current target device using it's deviceId.\n   *\n   * @param deviceId\n   */\n  changeDeviceById(deviceId: string): void {\n    this.changeDevice(this.getDeviceById(deviceId));\n  }\n\n  /**\n   * Properly returns the target device using it's deviceId.\n   *\n   * @param deviceId\n   */\n  getDeviceById(deviceId: string): MediaDeviceInfo {\n    return this.videoInputDevices.find(device => device.deviceId === deviceId);\n  }\n\n  /**\n   * Sets the permission value and emmits the event.\n   */\n  private setPermission(hasPermission: boolean | null) {\n    this.hasPermission = hasPermission;\n    this.permissionResponse.next(hasPermission);\n    return this.permissionResponse;\n  }\n\n  /**\n   * Gets and registers all cammeras.\n   *\n   * @todo Return a Promise.\n   */\n  async askForPermission(): Promise<boolean> {\n\n    if (!this.hasNavigator) {\n      console.error('zxing-scanner', 'askForPermission', 'Can\\'t ask permission, navigator is not present.');\n      this.setPermission(null);\n      return this.hasPermission;\n    }\n\n    if (!this.isMediaDevicesSuported) {\n      console.error('zxing-scanner', 'askForPermission', 'Can\\'t get user media, this is not supported.');\n      this.setPermission(null);\n      return this.hasPermission;\n    }\n\n    let stream: MediaStream;\n\n    try {\n      // Will try to ask for permission\n      stream = await navigator.mediaDevices.getUserMedia({ audio: false, video: true });\n    } catch (err) {\n      return this.handlePermissionException(err);\n    }\n\n    let permission: boolean;\n\n    try {\n\n      // Start stream so Browser can display its permission-dialog\n      this.codeReader.bindVideoSrc(this.previewElemRef.nativeElement, stream);\n\n      // After permission was granted, we can stop it again\n      stream.getVideoTracks().forEach(track => {\n        track.stop();\n      });\n\n      // should stop the opened stream\n      this.codeReader.unbindVideoSrc(this.previewElemRef.nativeElement);\n\n      // if the scripts lives until here, that's only one mean:\n\n      // permission granted\n      permission = true;\n      this.setPermission(permission);\n\n    } catch (err) {\n\n      console.error('zxing-scanner', 'askForPermission', err);\n\n      // permission aborted\n      permission = null;\n      this.setPermission(permission);\n    }\n\n    // Returns the event emitter, so the dev can subscribe to it\n    return permission;\n  }\n\n  /**\n   * Returns the filtered permission.\n   *\n   * @param err\n   */\n  private handlePermissionException(err: DOMException): boolean {\n\n    // failed to grant permission to video input\n\n    console.warn('zxing-scanner', 'askForPermission', err);\n\n    let permission: boolean;\n\n    switch (err.name) {\n\n      // usually caused by not secure origins\n      case 'NotSupportedError':\n        console.warn('@zxing/ngx-scanner', err.message);\n        // could not claim\n        permission = null;\n        // can't check devices\n        this._hasDevices = null;\n        break;\n\n      // user denied permission\n      case 'NotAllowedError':\n        console.warn('@zxing/ngx-scanner', err.message);\n        // claimed and denied permission\n        permission = false;\n        // this means that input devices exists\n        this._hasDevices = true;\n        break;\n\n      // the device has no attached input devices\n      case 'NotFoundError':\n        console.warn('@zxing/ngx-scanner', err.message);\n        // no permissions claimed\n        permission = null;\n        // because there was no devices\n        this._hasDevices = false;\n        // tells the listener about the error\n        this.camerasNotFound.next(err);\n        break;\n\n      case 'NotReadableError':\n        console.warn('@zxing/ngx-scanner', 'Couldn\\'t read the device(s)\\'s stream, it\\'s probably in use by another app.');\n        // no permissions claimed\n        permission = null;\n        // there are devices, which I couldn't use\n        this._hasDevices = false;\n        // tells the listener about the error\n        this.camerasNotFound.next(err);\n        break;\n\n      default:\n        console.warn('@zxing/ngx-scanner', 'I was not able to define if I have permissions for camera or not.', err);\n        // unknown\n        permission = null;\n        // this._hasDevices = undefined;\n        break;\n\n    }\n\n    this.setPermission(permission);\n\n    // tells the listener about the error\n    this.permissionResponse.error(err);\n\n    return permission;\n  }\n\n  /**\n   * Starts the continuous scanning for the given device.\n   *\n   * @param deviceId The deviceId from the device.\n   */\n  scan(deviceId: string): void {\n    try {\n\n      this.codeReader.decodeFromInputVideoDevice((result: Result) => {\n\n        if (result) {\n          this.dispatchScanSuccess(result);\n        } else {\n          this.dispatchScanFailure();\n        }\n\n        this.dispatchScanComplete(result);\n\n      }, deviceId, this.previewElemRef.nativeElement);\n\n    } catch (err) {\n      this.dispatchScanError(err);\n      this.dispatchScanComplete(undefined);\n    }\n  }\n\n  /**\n   * Starts scanning if allowed.\n   *\n   * @param device The device to be used in the scan.\n   */\n  startScan(device: MediaDeviceInfo): void {\n    if (this.scannerEnabled && device) {\n      this.scan(device.deviceId);\n    }\n  }\n\n  /**\n   * Stops the scan service.\n   */\n  resetCodeReader(): void {\n    if (this.codeReader) {\n      this.codeReader.reset();\n    }\n  }\n\n  /**\n   * Stops and starts back the scan.\n   */\n  restartScan(): void {\n    this.resetCodeReader();\n    this.startScan(this.device);\n  }\n\n  /**\n   * Stops old `codeReader` and starts scanning in a new one.\n   */\n  refreshCodeReader(): void {\n    this.resetCodeReader();\n    this.codeReader = new BrowserMultiFormatReader(this.hints);\n    this.startScan(this.device);\n  }\n\n  /**\n   * Dispatches the scan success event.\n   *\n   * @param result the scan result.\n   */\n  private dispatchScanSuccess(result: Result): void {\n    this.scanSuccess.next(result.getText());\n  }\n\n  /**\n   * Dispatches the scan failure event.\n   */\n  private dispatchScanFailure(): void {\n    this.scanFailure.next();\n  }\n\n  /**\n   * Dispatches the scan error event.\n   *\n   * @param err the error thing.\n   */\n  private dispatchScanError(error: any): void {\n    this.scanError.next(error);\n  }\n\n  /**\n   * Dispatches the scan event.\n   *\n   * @param result the scan result.\n   */\n  private dispatchScanComplete(result: Result): void {\n    this.scanComplete.next(result);\n  }\n\n  /**\n   * Enumerates all the available devices.\n   */\n  private async enumarateVideoDevices(): Promise<MediaDeviceInfo[]> {\n\n    if (!this.hasNavigator) {\n      console.error('zxing-scanner', 'enumarateVideoDevices', 'Can\\'t enumerate devices, navigator is not present.');\n      return;\n    }\n\n    if (!this.isEnumerateDevicesSuported) {\n      console.error('zxing-scanner', 'enumarateVideoDevices', 'Can\\'t enumerate devices, method not supported.');\n      return;\n    }\n\n    const devices = await navigator.mediaDevices.enumerateDevices();\n\n    this.videoInputDevices = [];\n\n    for (const device of devices) {\n\n      // @todo type this as `MediaDeviceInfo`\n      const videoDevice: any = {};\n\n      // tslint:disable-next-line:forin\n      for (const key in device) {\n        videoDevice[key] = device[key];\n      }\n\n      if (videoDevice.kind === 'video') {\n        videoDevice.kind = 'videoinput';\n      }\n\n      if (!videoDevice.deviceId) {\n        videoDevice.deviceId = (<any>videoDevice).id;\n      }\n\n      if (!videoDevice.label) {\n        videoDevice.label = 'Camera (no permission ðŸš«)';\n      }\n\n      if (videoDevice.kind === 'videoinput') {\n        this.videoInputDevices.push(videoDevice);\n      }\n    }\n\n    return this.videoInputDevices;\n  }\n\n  /**\n   * Returns a valid BarcodeFormat or fails.\n   */\n  private getBarcodeFormat(format: string | BarcodeFormat): BarcodeFormat {\n    return typeof format === 'string'\n      ? BarcodeFormat[format.trim().toUpperCase()]\n      : format;\n  }\n}\n",
    "import { NgModule, ModuleWithProviders } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { FormsModule } from '@angular/forms';\n\nimport { ZXingScannerComponent } from './zxing-scanner.component';\n\n@NgModule({\n  imports: [\n    CommonModule,\n    FormsModule\n  ],\n  declarations: [ZXingScannerComponent],\n  exports: [ZXingScannerComponent],\n})\nexport class ZXingScannerModule {\n  static forRoot(): ModuleWithProviders {\n    return {\n      ngModule: ZXingScannerModule\n    };\n  }\n}\n"
  ],
  "names": [
    "extendStatics",
    "d",
    "b",
    "Object",
    "setPrototypeOf",
    "__proto__",
    "Array",
    "p",
    "hasOwnProperty",
    "__awaiter",
    "thisArg",
    "_arguments",
    "P",
    "generator",
    "Promise",
    "resolve",
    "reject",
    "fulfilled",
    "value",
    "step",
    "next",
    "e",
    "rejected",
    "result",
    "done",
    "then",
    "apply",
    "__generator",
    "body",
    "f",
    "y",
    "t",
    "g",
    "_",
    "label",
    "sent",
    "trys",
    "ops",
    "verb",
    "throw",
    "return",
    "Symbol",
    "iterator",
    "this",
    "n",
    "v",
    "op",
    "TypeError",
    "call",
    "pop",
    "length",
    "push",
    "BrowserMultiFormatReader",
    "_super",
    "hints",
    "timeBetweenScansMillis",
    "reader",
    "MultiFormatReader",
    "setHints",
    "__extends",
    "__",
    "constructor",
    "prototype",
    "create",
    "tslib_1.__extends",
    "decodeBitmap",
    "binaryBitmap",
    "decodeWithState",
    "BrowserCodeReader",
    "timeBetweenScans",
    "torchCompatible",
    "BehaviorSubject",
    "decodeFromInputVideoDevice",
    "callbackFn",
    "deviceId",
    "videoElement",
    "reset",
    "prepareVideoElement",
    "constraints",
    "audio",
    "video",
    "facingMode",
    "exact",
    "navigator",
    "mediaDevices",
    "getUserMedia",
    "stream",
    "_a",
    "startDecodeFromStream",
    "console",
    "error",
    "err_1",
    "checkTorchCompatibility",
    "bindVideoSrc",
    "bindEvents",
    "srcObject",
    "err",
    "src",
    "window",
    "URL",
    "createObjectURL",
    "unbindVideoSrc",
    "_this",
    "videoPlayingEventListener",
    "decodingStream",
    "decodeWithDelay",
    "pipe",
    "catchError",
    "x",
    "handleDecodeStreamError",
    "subscribe",
    "addEventListener",
    "videoLoadedMetadataEventListener",
    "play",
    "track",
    "getVideoTracks",
    "ImageCapture",
    "getPhotoCapabilities",
    "capabilities",
    "compatible",
    "torch",
    "fillLightMode",
    "setTorch",
    "on",
    "applyConstraints",
    "advanced",
    "restart",
    "defineProperty",
    "get",
    "asObservable",
    "document",
    "createElement",
    "width",
    "height",
    "delay",
    "Observable",
    "observer",
    "intervalId",
    "setInterval",
    "decode",
    "clearInterval",
    "createBinaryBitmap",
    "imageElement",
    "caught",
    "NotFoundException",
    "ChecksumException",
    "FormatException",
    "mediaElement",
    "undefined",
    "canvasElementContext",
    "prepareCaptureCanvas",
    "drawImage",
    "luminanceSource",
    "HTMLCanvasElementLuminanceSource",
    "canvasElement",
    "hybridBinarizer",
    "HybridBinarizer",
    "BinaryBitmap",
    "videoWidth",
    "videoHeight",
    "naturalWidth",
    "naturalHeight",
    "style",
    "getContext",
    "stop",
    "unsubscribe",
    "forEach",
    "videoPlayEndedEventListener",
    "removeEventListener",
    "removeAttribute",
    "imageLoadedEventListener",
    "ZXingScannerComponent",
    "scannerEnabled",
    "autofocusEnabled",
    "previewFitMode",
    "EventEmitter",
    "scanSuccess",
    "scanFailure",
    "scanError",
    "scanComplete",
    "camerasFound",
    "camerasNotFound",
    "permissionResponse",
    "hasDevices",
    "_hints",
    "Map",
    "hasNavigator",
    "isMediaDevicesSuported",
    "isEnumerateDevicesSuported",
    "enumerateDevices",
    "formats",
    "BarcodeFormat",
    "QR_CODE",
    "set",
    "hasDevice",
    "input",
    "Error",
    "map",
    "getBarcodeFormat",
    "refreshCodeReader",
    "codeReader",
    "enable",
    "delete",
    "ngOnChanges",
    "changes",
    "videoInputDevice",
    "scan",
    "resetCodeReader",
    "device",
    "changeDevice",
    "warn",
    "ngAfterViewInit",
    "previewElemRef",
    "nativeElement",
    "setAttribute",
    "askForPermission",
    "hasPermission",
    "enumarateVideoDevices",
    "videoInputDevices",
    "_hasDevices",
    "startScan",
    "torchAvailable",
    "emit",
    "ngOnDestroy",
    "changeDeviceById",
    "getDeviceById",
    "find",
    "setPermission",
    "handlePermissionException",
    "err_3",
    "permission",
    "name",
    "message",
    "dispatchScanSuccess",
    "dispatchScanFailure",
    "dispatchScanComplete",
    "dispatchScanError",
    "restartScan",
    "getText",
    "devices",
    "_b",
    "devices_1",
    "__values",
    "o",
    "m",
    "i",
    "tslib_1.__values",
    "devices_1_1",
    "key",
    "videoDevice",
    "kind",
    "id",
    "format",
    "trim",
    "toUpperCase",
    "type",
    "Component",
    "args",
    "selector",
    "template",
    "styles",
    "changeDetection",
    "ChangeDetectionStrategy",
    "OnPush",
    "ViewChild",
    "Input",
    "Output",
    "tryHarder",
    "ZXingScannerModule",
    "forRoot",
    "ngModule",
    "NgModule",
    "imports",
    "CommonModule",
    "FormsModule",
    "declarations",
    "exports"
  ],
  "mappings": "wjBAgBA,IAAIA,EAAgB,SAASC,EAAGC,GAI5B,OAHAF,EAAgBG,OAAOC,gBAClB,CAAEC,UAAW,cAAgBC,OAAS,SAAUL,EAAGC,GAAKD,EAAEI,UAAYH,IACvE,SAAUD,EAAGC,GAAK,IAAK,IAAIK,KAAKL,EAAOA,EAAEM,eAAeD,KAAIN,EAAEM,GAAKL,EAAEK,MACpDN,EAAGC,IA6C5B,SAAgBO,EAAUC,EAASC,EAAYC,EAAGC,GAC9C,OAAO,IAAKD,IAAMA,EAAIE,UAAU,SAAUC,EAASC,GAC/C,SAASC,EAAUC,GAAS,IAAMC,EAAKN,EAAUO,KAAKF,IAAW,MAAOG,GAAKL,EAAOK,IACpF,SAASC,EAASJ,GAAS,IAAMC,EAAKN,EAAiB,SAAEK,IAAW,MAAOG,GAAKL,EAAOK,IACvF,SAASF,EAAKI,GAAUA,EAAOC,KAAOT,EAAQQ,EAAOL,OAAS,IAAIN,EAAE,SAAUG,GAAWA,EAAQQ,EAAOL,SAAWO,KAAKR,EAAWK,GACnIH,GAAMN,EAAYA,EAAUa,MAAMhB,EAASC,GAAc,KAAKS,UAItE,SAAgBO,EAAYjB,EAASkB,GACjC,IAAsGC,EAAGC,EAAGC,EAAGC,EAA3GC,EAAI,CAAEC,MAAO,EAAGC,KAAM,WAAa,GAAW,EAAPJ,EAAE,GAAQ,MAAMA,EAAE,GAAI,OAAOA,EAAE,IAAOK,KAAM,GAAIC,IAAK,IAChG,OAAOL,EAAI,CAAEZ,KAAMkB,EAAK,GAAIC,QAASD,EAAK,GAAIE,SAAUF,EAAK,IAAwB,mBAAXG,SAA0BT,EAAES,OAAOC,UAAY,WAAa,OAAOC,OAAUX,EACvJ,SAASM,EAAKM,GAAK,OAAO,SAAUC,GAAK,OACzC,SAAS1B,EAAK2B,GACV,GAAIjB,EAAG,MAAM,IAAIkB,UAAU,mCAC3B,KAAOd,GAAG,IACN,GAAIJ,EAAI,EAAGC,IAAMC,EAAY,EAARe,EAAG,GAAShB,EAAU,UAAIgB,EAAG,GAAKhB,EAAS,YAAOC,EAAID,EAAU,YAAMC,EAAEiB,KAAKlB,GAAI,GAAKA,EAAEV,SAAWW,EAAIA,EAAEiB,KAAKlB,EAAGgB,EAAG,KAAKtB,KAAM,OAAOO,EAE3J,OADID,EAAI,EAAGC,IAAGe,EAAK,CAAS,EAARA,EAAG,GAAQf,EAAEb,QACzB4B,EAAG,IACP,KAAK,EAAG,KAAK,EAAGf,EAAIe,EAAI,MACxB,KAAK,EAAc,OAAXb,EAAEC,QAAgB,CAAEhB,MAAO4B,EAAG,GAAItB,MAAM,GAChD,KAAK,EAAGS,EAAEC,QAASJ,EAAIgB,EAAG,GAAIA,EAAK,CAAC,GAAI,SACxC,KAAK,EAAGA,EAAKb,EAAEI,IAAIY,MAAOhB,EAAEG,KAAKa,MAAO,SACxC,QACI,KAAkBlB,EAAe,GAA3BA,EAAIE,EAAEG,MAAYc,QAAcnB,EAAEA,EAAEmB,OAAS,MAAkB,IAAVJ,EAAG,IAAsB,IAAVA,EAAG,IAAW,CAAEb,EAAI,EAAG,SACjG,GAAc,IAAVa,EAAG,MAAcf,GAAMe,EAAG,GAAKf,EAAE,IAAMe,EAAG,GAAKf,EAAE,IAAM,CAAEE,EAAEC,MAAQY,EAAG,GAAI,MAC9E,GAAc,IAAVA,EAAG,IAAYb,EAAEC,MAAQH,EAAE,GAAI,CAAEE,EAAEC,MAAQH,EAAE,GAAIA,EAAIe,EAAI,MAC7D,GAAIf,GAAKE,EAAEC,MAAQH,EAAE,GAAI,CAAEE,EAAEC,MAAQH,EAAE,GAAIE,EAAEI,IAAIc,KAAKL,GAAK,MACvDf,EAAE,IAAIE,EAAEI,IAAIY,MAChBhB,EAAEG,KAAKa,MAAO,SAEtBH,EAAKlB,EAAKoB,KAAKtC,EAASuB,GAC1B,MAAOZ,GAAKyB,EAAK,CAAC,EAAGzB,GAAIS,EAAI,EAAI,QAAWD,EAAIE,EAAI,EACtD,GAAY,EAARe,EAAG,GAAQ,MAAMA,EAAG,GAAI,MAAO,CAAE5B,MAAO4B,EAAG,GAAKA,EAAG,QAAK,EAAQtB,MAAM,GArB9BL,CAAK,CAACyB,EAAGC,MCnD7D,IC1BAO,EAAA,SAAAC,GAQE,SAAFD,EACIE,EACAC,QADJ,IAAAD,IAAIA,EAAJ,WACA,IAAAC,IAAIA,EAAJ,KAFE,IAIQC,EAAS,IAAIC,EAAAA,yBACnBD,EAAOE,SAASJ,GAChBD,EAAJL,KAAAL,KAAUa,EAAQD,IAAlBZ,KAUA,OFDA,SAAgBgB,EAAU1D,EAAGC,GAEzB,SAAS0D,IAAOjB,KAAKkB,YAAc5D,EADnCD,EAAcC,EAAGC,GAEjBD,EAAE6D,UAAkB,OAAN5D,EAAaC,OAAO4D,OAAO7D,IAAM0D,EAAGE,UAAY5D,EAAE4D,UAAW,IAAIF,GEtBrCI,CAA9CA,EAAAA,GAiBYZ,EAAZU,UAAAG,aAAY,SAAaC,GACrB,OAAOvB,KAAKa,OAAOW,gBAAgBD,IAEvCd,EAxBA,CD0BA,WAsEE,SAAFgB,EAAwCZ,EAAwBa,QAAhE,IAAAA,IAAgEA,EAAhE,KAAwC1B,KAAxCa,OAAwCA,EAAwBb,KAAhE0B,iBAAgEA,EAbtD1B,KAAV2B,gBAA4B,IAAIC,EAAAA,iBAAyB,GAwXzD,OAhWeH,EAAfN,UAAAU,2BAAe,SACXC,EACAC,EACAC,qGAqBA,GAlBAhC,KAAKiC,QAELjC,KAAKkC,oBAAoBF,QAGD,IAAbD,IACT/B,KAAK+B,SAAWA,GAOZI,EAAsC,CAC1CC,OAAO,EACPC,WANgC,IAAbN,EACjB,CAAEO,WAAY,CAAEC,MAAO,gBACvB,CAAER,SAAU,CAAEQ,MAAOR,KAOA,oBAAdS,UACT,MAAN,CAAA,oBAIqB,6BAArB,CAAA,EAA2BA,UAClBC,aACAC,aAAaP,kBAFVQ,EAASC,EAArBpD,OAIMQ,KAAK6C,sBAAsBF,EAAQb,kCAInCgB,QAAQC,MAAMC,gCAYVvB,EAAVN,UAAA0B,sBAAU,SAAsBF,EAAqBb,GACjD9B,KAAK2C,OAASA,EACd3C,KAAKiD,wBAAwBjD,KAAK2C,QAClC3C,KAAKkD,aAAalD,KAAKgC,aAAchC,KAAK2C,QAC1C3C,KAAKmD,WAAWnD,KAAKgC,aAAcF,IAS9BL,EAATN,UAAA+B,aAAS,SAAalB,EAAgCW,GAElD,IAEEX,EAAaoB,UAAYT,EACzB,MAAOU,GAEPrB,EAAasB,IAAMC,OAAOC,IAAIC,gBAAgBd,KAS3ClB,EAATN,UAAAuC,eAAS,SAAe1B,GACpB,IACEA,EAAaoB,UAAY,KACzB,MAAOC,GACPrB,EAAasB,IAAM,KAUf7B,EAAVN,UAAAgC,WAAU,SAAWnB,EAAgCF,GAA3C,IAAV6B,EAAA3D,UAE8B,IAAf8B,IACT9B,KAAK4D,0BAA4B,WAAM,OAAAD,EAAKE,eAAiBF,EAAKG,gBAAgBH,EAAKjC,kBACpFqC,KAAKC,EAAAA,WAAW,SAACtF,EAAGuF,GAAM,OAAAN,EAAKO,wBAAwBxF,EAAGuF,MAC1DE,UAAU,SAACF,GAAc,OAAAnC,EAAWmC,OAGzCjC,EAAaoC,iBAAiB,UAAWpE,KAAK4D,2BAE9C5D,KAAKqE,iCAAmC,WAAM,OAAArC,EAAasC,QAE3DtC,EAAaoC,iBAAiB,iBAAkBpE,KAAKqE,mCAQzC5C,EAAhBN,UAAA8B,wBAAgB,SAAwBN,mGAIb,6BAFrB3C,KAAKuE,MAAQ5B,EAAO6B,iBAAiB,GAE3C,CAAA,EAD2B,IAAIC,aAAazE,KAAKuE,OACHG,sCAAlCC,EAAe/B,EAA3BpD,OACYoF,IAAeD,EAAaE,OAAU,kBAAmBF,GAAsD,IAAtCA,EAAaG,cAAcvE,OAC1GP,KAAK2B,gBAAgBlD,KAAKmG,gCAE1B5E,KAAK2B,gBAAgBlD,MAAK,gCAOvBgD,EAATN,UAAA4D,SAAS,SAASC,GACThF,KAAK2B,gBAAgBpD,QAGtByG,EACFhF,KAAKuE,MAAMU,iBAAiB,CAC1BC,SAAU,CAAA,CAAQL,OAAO,MAG3B7E,KAAKmF,YAOT3H,OAAF4H,eAAa3D,EAAbN,UAAA,iBAAA,CAAAkE,IAAE,WACE,OAAOrF,KAAK2B,gBAAgB2D,gDAQtB7D,EAAVN,UAAAe,oBAAU,SAAoBF,GAErBA,GAAoC,oBAAbuD,YAC1BvD,EAAeuD,SAASC,cAAc,UACzBC,MAAQ,IACrBzD,EAAa0D,OAAS,KAGxB1F,KAAKgC,aAAeA,GAMdP,EAAVN,UAAA2C,gBAAU,SAAgB6B,GAAhB,IAAVhC,EAAA3D,KAEI,YAFJ,IAAA2F,IAA0BA,EAA1B,KAEWC,EAAAA,WAAWxE,OAAO,SAACyE,GAE9B,IAAYC,EAAaC,YAAY,WAC7B,IACEF,EAASpH,KAAKkF,EAAKqC,UACnB,MAAO3C,GACPwC,EAAS9C,MAAMM,KAEhBsC,GAEH,OAAO,WAAM,OAAAM,cAAcH,OAOvBrE,EAAVN,UAAA6E,OAAU,WAGV,IAAUzE,EAAevB,KAAKkG,mBAAmBlG,KAAKgC,cAAgBhC,KAAKmG,cAEvE,OAAOnG,KAAKsB,aAAaC,IAMjBE,EAAZN,UAAAG,aAAY,SAAaC,GACrB,OAAOvB,KAAKa,OAAOmF,OAAOzE,IAMpBE,EAAVN,UAAA+C,wBAAU,SAAwBb,EAAgB+C,GAE9C,GAEE/C,aAAegD,EAAAA,mBAEfhD,aAAeiD,EAAAA,mBACfjD,aAAekD,EAAAA,gBAEf,OAAOH,EAGT,MAAM/C,GAQA5B,EAAVN,UAAA+E,mBAAU,SAAmBM,GAErBC,YAAczG,KAAK0G,sBACrB1G,KAAK2G,uBAGP3G,KAAK0G,qBAAqBE,UAAUJ,EAAc,EAAG,GAEzD,IAAUK,EAAkB,IAAIC,EAAAA,iCAAiC9G,KAAK+G,eAC5DC,EAAkB,IAAIC,EAAAA,gBAAgBJ,GAE5C,OAAO,IAAIK,EAAAA,aAAaF,IAMlBvF,EAAVN,UAAAwF,qBAAU,WAEN,GAAwB,oBAAbpB,SAKT,OAHAvF,KAAK+G,cAAgBN,eACrBzG,KAAK0G,qBAAuBD,WAKlC,IAEQhB,EACAC,EAHEqB,EAAgBxB,SAASC,cAAc,UAKZ,oBAAtBxF,KAAKgC,eACdyD,EAAQzF,KAAKgC,aAAamF,WAC1BzB,EAAS1F,KAAKgC,aAAaoF,aAGI,oBAAtBpH,KAAKmG,eACdV,EAAQzF,KAAKmG,aAAakB,cAAgBrH,KAAKmG,aAAaV,MAC5DC,EAAS1F,KAAKmG,aAAamB,eAAiBtH,KAAKmG,aAAaT,QAGhEqB,EAAcQ,MAAM9B,MAAQA,EAAQ,KACpCsB,EAAcQ,MAAM7B,OAASA,EAAS,KACtCqB,EAActB,MAAQA,EACtBsB,EAAcrB,OAASA,EAEvB1F,KAAK+G,cAAgBA,EACrB/G,KAAK0G,qBAAuBK,EAAcS,WAAW,OAM/C/F,EAAVN,UAAAsG,KAAU,WAEFzH,KAAK6D,gBACP7D,KAAK6D,eAAe6D,cAGlB1H,KAAK2C,SACP3C,KAAK2C,OAAO6B,iBAAiBmD,QAAQ,SAAAvI,GAAK,OAAAA,EAAEqI,SAC5CzH,KAAK2C,OAAS8D,YAQXhF,EAATN,UAAAc,MAAS,WAILjC,KAAKyH,OAEDzH,KAAKgC,eAIyC,oBAArChC,KAAK4H,6BACd5H,KAAKgC,aAAa6F,oBAAoB,QAAS7H,KAAK4H,6BAGR,oBAAnC5H,KAAK4D,2BACd5D,KAAKgC,aAAa6F,oBAAoB,UAAW7H,KAAK4D,2BAGH,oBAA1C5D,KAAKqE,kCACdrE,KAAKgC,aAAa6F,oBAAoB,iBAAkB7H,KAAKqE,kCAK/DrE,KAAK0D,eAAe1D,KAAKgC,cAEzBhC,KAAKgC,aAAa8F,gBAAgB,OAClC9H,KAAKgC,aAAeyE,WAGlBzG,KAAKmG,eAIHM,YAAczG,KAAK4H,6BACrB5H,KAAKmG,aAAa0B,oBAAoB,OAAQ7H,KAAK+H,0BAKrD/H,KAAKmG,aAAa7C,IAAMmD,UACxBzG,KAAKmG,aAAa2B,gBAAgB,OAClC9H,KAAKmG,aAAeM,WAKtBzG,KAAK0G,qBAAuBD,UAC5BzG,KAAK+G,cAAgBN,WAMfhF,EAAVN,UAAAgE,QAAU,WAGNnF,KAAK6B,2BAA2B4E,UAAWzG,KAAK+B,SAAU/B,KAAKgC,eAEnEP,EAjbA,IEOAuG,EAAA,WA0ME,SAAFA,IA/IEhI,KAAFiI,gBAAmB,EAYjBjI,KAAFkI,kBAAqB,EAMnBlI,KAAFmI,eAAyE,QAMvEnI,KAAF2B,gBAAoB,IAAIyG,EAAAA,aAMtBpI,KAAFqI,YAAgB,IAAID,EAAAA,aAMlBpI,KAAFsI,YAAgB,IAAIF,EAAAA,aAMlBpI,KAAFuI,UAAc,IAAIH,EAAAA,aAMhBpI,KAAFwI,aAAiB,IAAIJ,EAAAA,aAMnBpI,KAAFyI,aAAiB,IAAIL,EAAAA,aAMnBpI,KAAF0I,gBAAoB,IAAIN,EAAAA,aAMtBpI,KAAF2I,mBAAuB,IAAIP,EAAAA,aAMzBpI,KAAF4I,WAAe,IAAIR,EAAAA,aAwEfpI,KAAK6I,OAAS,IAAIC,IAClB9I,KAAK+I,aAAoC,oBAAdvG,UAC3BxC,KAAKgJ,uBAAyBhJ,KAAK+I,gBAAkBvG,UAAUC,aAC/DzC,KAAKiJ,8BAAgCjJ,KAAKgJ,yBAA0BxG,UAAUC,aAAayG,kBAG3FlJ,KAAKmJ,QAAU,CAACC,EAAAA,cAAcC,gBApKhC7L,OAAF4H,eAAc4C,EAAd7G,UAAA,cAAA,CAAAmI,IAAE,SAAwBC,GACtBvJ,KAAK4I,WAAWnK,KAAK8K,oCA0FvB/L,OAAF4H,eAAM4C,EAAN7G,UAAA,UAAA,CAAAkE,IAAE,WACE,OAAOrF,KAAKW,MAAM0E,IAAtB,IAQAiE,IAAE,SACYE,GADZ,IAAF7F,EAAA3D,KAGI,GAAqB,iBAAVwJ,EACT,MAAM,IAAIC,MAAM,gEAItB,IAAUN,EAAUK,EAAME,IAAI,SAAAxK,GAAK,OAAAyE,EAAKgG,iBAAiBzK,KAGrDc,KAAKW,MAAM2I,IAAf,EAAoDH,GAGhDnJ,KAAK4J,qDAMPpM,OAAF4H,eAAM4C,EAAN7G,UAAA,QAAA,CAAAkE,IAAE,WACE,OAAOrF,KAAK6I,wCAMdrL,OAAF4H,eACM4C,EADN7G,UAAA,QAAA,CAAAmI,IAAE,SACUtE,GACRhF,KAAK6J,WAAW9E,SAASC,oCAM3BxH,OAAF4H,eAAM4C,EAAN7G,UAAA,YAAA,CAAAkE,IAAE,WACE,OAAOrF,KAAKW,MAAM0E,IAAtB,IAMAiE,IAAE,SACcQ,GACRA,EACF9J,KAAKW,MAAM2I,IAAjB,GAAgD,GAE1CtJ,KAAKW,MAAMoJ,UAAjB,GAII/J,KAAK4J,qDAoBP5B,EAAF7G,UAAA6I,YAAE,SAAYC,GAENA,EAAQhC,iBACLjI,KAAKiI,eAECjI,KAAKkK,kBACdlK,KAAKmK,KAAKnK,KAAKkK,iBAAiBnI,UAFhC/B,KAAKoK,mBAMLH,EAAQI,SACNrK,KAAKqK,OACPrK,KAAKsK,aAAatK,KAAKqK,SAEvBvH,QAAQyH,KAAK,gBAAiB,SAAU,sBACxCvK,KAAKoK,qBAQLpC,EAAR7G,UAAAqJ,gBAAQ,wDAwCR7G,EAAA3D,sDArCI,OAAKA,KAAKyK,gBAMVzK,KAAKyK,eAAeC,cAAcC,aAAa,YAAY,GAC3D3K,KAAKyK,eAAeC,cAAcC,aAAa,SAAS,GACxD3K,KAAKyK,eAAeC,cAAcC,aAAa,eAAe,GAC9D3K,KAAKyK,eAAeC,cAAcC,aAAa,YAAa3K,KAAKkI,kBAGrE,CAAA,EAAgClI,KAAK4K,sBAX/B9H,QAAQyH,KAAK,gBAAiB,8BACpC,CAAA,WA0BI,OAhBMM,EAAgBjI,EAA1BpD,OAGIQ,KAAK8K,wBAAwBhM,KAAK,SAACiM,GAE7BA,GAAgD,EAA3BA,EAAkBxK,QACzCoD,EAAKqH,aAAc,EACnBrH,EAAK8E,aAAahK,KAAKsM,KAEvBpH,EAAKqH,aAAc,EACnBrH,EAAK+E,gBAAgBjK,WAMH,IAAlBoM,EACR,CAAA,IAGI7K,KAAKiL,UAAUjL,KAAKkK,kBAEpBlK,KAAK6J,WAAWqB,eAAe/G,UAAU,SAAC5F,GACxCoF,EAAKhC,gBAAgBwJ,KAAK5M,gBAO9ByJ,EAAF7G,UAAAiK,YAAE,WACEpL,KAAKoK,mBAQPpC,EAAF7G,UAAAmJ,aAAE,SAAaD,GACXrK,KAAKoK,kBACLpK,KAAKkK,iBAAmBG,EACxBrK,KAAKiL,UAAUZ,IAQjBrC,EAAF7G,UAAAkK,iBAAE,SAAiBtJ,GACf/B,KAAKsK,aAAatK,KAAKsL,cAAcvJ,KAQvCiG,EAAF7G,UAAAmK,cAAE,SAAcvJ,GACZ,OAAO/B,KAAK+K,kBAAkBQ,KAAK,SAAAlB,GAAU,OAAAA,EAAOtI,WAAaA,KAM3DiG,EAAV7G,UAAAqK,cAAU,SAAcX,GAGpB,OAFA7K,KAAK6K,cAAgBA,EACrB7K,KAAK2I,mBAAmBlK,KAAKoM,GACtB7K,KAAK2I,oBAQRX,EAAR7G,UAAAyJ,iBAAQ,6GAEJ,IAAK5K,KAAK+I,aAGR,OAFAjG,QAAQC,MAAM,gBAAiB,mBAAoB,mDACnD/C,KAAKwL,cAAc,MACzB,CAAA,EAAaxL,KAAK6K,eAGd,IAAK7K,KAAKgJ,uBAGR,OAFAlG,QAAQC,MAAM,gBAAiB,mBAAoB,gDACnD/C,KAAKwL,cAAc,MACzB,CAAA,EAAaxL,KAAK6K,gCAOH,6BAAf,CAAA,EAAqBrI,UAAUC,aAAaC,aAAa,CAAEN,OAAO,EAAOC,OAAO,mBAA1EM,EAASC,EAAfpD,oBAEM,kBAAN,CAAA,EAAaQ,KAAKyL,0BAA0BC,WAKxC,IAGE1L,KAAK6J,WAAW3G,aAAalD,KAAKyK,eAAeC,cAAe/H,GAGhEA,EAAO6B,iBAAiBmD,QAAQ,SAAApD,GAC9BA,EAAMkD,SAIRzH,KAAK6J,WAAWnG,eAAe1D,KAAKyK,eAAeC,eAKnDiB,GAAa,EACb3L,KAAKwL,cAAcG,GAEnB,MAAOtI,GAEPP,QAAQC,MAAM,gBAAiB,mBAAoBM,GAGnDsI,EAAa,KACb3L,KAAKwL,cAAcG,GAIrB,MAAJ,CAAA,EAAWA,SAQD3D,EAAV7G,UAAAsK,0BAAU,SAA0BpI,GAMpC,IAAQsI,EAEJ,OAJA7I,QAAQyH,KAAK,gBAAiB,mBAAoBlH,GAI1CA,EAAIuI,MAGV,IAAK,oBACH9I,QAAQyH,KAAK,qBAAsBlH,EAAIwI,SAEvCF,EAAa,KAEb3L,KAAKgL,YAAc,KACnB,MAGF,IAAK,kBACHlI,QAAQyH,KAAK,qBAAsBlH,EAAIwI,SAEvCF,GAAa,EAEb3L,KAAKgL,aAAc,EACnB,MAGF,IAAK,gBACHlI,QAAQyH,KAAK,qBAAsBlH,EAAIwI,SAEvCF,EAAa,KAEb3L,KAAKgL,aAAc,EAEnBhL,KAAK0I,gBAAgBjK,KAAK4E,GAC1B,MAEF,IAAK,mBACHP,QAAQyH,KAAK,qBAAsB,8EAEnCoB,EAAa,KAEb3L,KAAKgL,aAAc,EAEnBhL,KAAK0I,gBAAgBjK,KAAK4E,GAC1B,MAEF,QACEP,QAAQyH,KAAK,qBAAsB,oEAAqElH,GAExGsI,EAAa,KAWjB,OALA3L,KAAKwL,cAAcG,GAGnB3L,KAAK2I,mBAAmB5F,MAAMM,GAEvBsI,GAQT3D,EAAF7G,UAAAgJ,KAAE,SAAKpI,GAAL,IAAF4B,EAAA3D,KACI,IAEEA,KAAK6J,WAAWhI,2BAA2B,SAACjD,GAEtCA,EACF+E,EAAKmI,oBAAoBlN,GAEzB+E,EAAKoI,sBAGPpI,EAAKqI,qBAAqBpN,IAEzBmD,EAAU/B,KAAKyK,eAAeC,eAEjC,MAAOrH,GACPrD,KAAKiM,kBAAkB5I,GACvBrD,KAAKgM,qBAAqBvF,aAS9BuB,EAAF7G,UAAA8J,UAAE,SAAUZ,GACJrK,KAAKiI,gBAAkBoC,GACzBrK,KAAKmK,KAAKE,EAAOtI,WAOrBiG,EAAF7G,UAAAiJ,gBAAE,WACMpK,KAAK6J,YACP7J,KAAK6J,WAAW5H,SAOpB+F,EAAF7G,UAAA+K,YAAE,WACElM,KAAKoK,kBACLpK,KAAKiL,UAAUjL,KAAKqK,SAMtBrC,EAAF7G,UAAAyI,kBAAE,WACE5J,KAAKoK,kBACLpK,KAAK6J,WAAa,IAAIpJ,EAAyBT,KAAKW,OACpDX,KAAKiL,UAAUjL,KAAKqK,SAQdrC,EAAV7G,UAAA2K,oBAAU,SAAoBlN,GAC1BoB,KAAKqI,YAAY5J,KAAKG,EAAOuN,YAMvBnE,EAAV7G,UAAA4K,oBAAU,WACN/L,KAAKsI,YAAY7J,QAQXuJ,EAAV7G,UAAA8K,kBAAU,SAAkBlJ,GACxB/C,KAAKuI,UAAU9J,KAAKsE,IAQdiF,EAAV7G,UAAA6K,qBAAU,SAAqBpN,GAC3BoB,KAAKwI,aAAa/J,KAAKG,IAMXoJ,EAAhB7G,UAAA2J,sBAAgB,uHAEZ,OAAK9K,KAAK+I,aAKL/I,KAAKiJ,2BAKd,CAAA,EAA0BzG,UAAUC,aAAayG,qBAJ3CpG,QAAQC,MAAM,gBAAiB,wBAAyB,kDAC9D,CAAA,KANMD,QAAQC,MAAM,gBAAiB,wBAAyB,sDAC9D,CAAA,WAQUqJ,EAAUC,EAApB7M,OAEIQ,KAAK+K,kBAAoB,OAEzB,IAAqBuB,EHtfzB,SAAgBC,EAASC,GACrB,IAAIC,EAAsB,mBAAX3M,QAAyB0M,EAAE1M,OAAOC,UAAW2M,EAAI,EAChE,OAAID,EAAUA,EAAEpM,KAAKmM,GACd,CACH/N,KAAM,WAEF,OADI+N,GAAKE,GAAKF,EAAEjM,SAAQiM,OAAI,GACrB,CAAEjO,MAAOiO,GAAKA,EAAEE,KAAM7N,MAAO2N,KGgfvBG,CAAAP,GAAzBQ,EAAAN,EAAA7N,QAAAmO,EAAA/N,KAAA+N,EAAAN,EAAA7N,OAAkC,CAM5B,IAAWoO,KANFxC,EAAfuC,EAAArO,MAGYuO,EAAmB,GAGPzC,EAChByC,EAAYD,GAAOxC,EAAOwC,GAGH,UAArBC,EAAYC,OACdD,EAAYC,KAAO,cAGhBD,EAAY/K,WACf+K,EAAY/K,SAAW,EAAmBiL,IAGvCF,EAAYvN,QACfuN,EAAYvN,MAAQ,6BAGG,eAArBuN,EAAYC,MACd/M,KAAK+K,kBAAkBvK,KAAKsM,wGAIhC,MAAJ,CAAA,EAAW9M,KAAK+K,yBAMN/C,EAAV7G,UAAAwI,iBAAU,SAAiBsD,GACvB,MAAyB,iBAAXA,EACV7D,EAAAA,cAAc6D,EAAOC,OAAOC,eAC5BF,KAnmBR,iBAfA,CAAAG,KAACC,EAAAA,UAADC,KAAA,CAAW,CAETC,SAAU,gBACVC,SAAU,sPASVC,OAAQ,CAAC,8FACTC,gBAAiBC,EAAAA,wBAAwBC,mEAsD3CnD,eAAA,CAAA,CAAA2C,KAAGS,EAAAA,UAAHP,KAAA,CAAa,aAMbrF,eAAA,CAAA,CAAAmF,KAAGU,EAAAA,QAMHzD,OAAA,CAAA,CAAA+C,KAAGU,EAAAA,QAMH5F,iBAAA,CAAA,CAAAkF,KAAGU,EAAAA,QAMH3F,eAAA,CAAA,CAAAiF,KAAGU,EAAAA,QAMHnM,gBAAA,CAAA,CAAAyL,KAAGW,EAAAA,SAMH1F,YAAA,CAAA,CAAA+E,KAAGW,EAAAA,SAMHzF,YAAA,CAAA,CAAA8E,KAAGW,EAAAA,SAMHxF,UAAA,CAAA,CAAA6E,KAAGW,EAAAA,SAMHvF,aAAA,CAAA,CAAA4E,KAAGW,EAAAA,SAMHtF,aAAA,CAAA,CAAA2E,KAAGW,EAAAA,SAMHrF,gBAAA,CAAA,CAAA0E,KAAGW,EAAAA,SAMHpF,mBAAA,CAAA,CAAAyE,KAAGW,EAAAA,SAMHnF,WAAA,CAAA,CAAAwE,KAAGW,EAAAA,SAeH5E,QAAA,CAAA,CAAAiE,KAAGU,EAAAA,QA2BHjJ,MAAA,CAAA,CAAAuI,KAAGU,EAAAA,QAeHE,UAAA,CAAA,CAAAZ,KAAGU,EAAAA,SC5NH,IAAAG,EAAA,WAAA,SAAAA,YAeSA,EAATC,QAAE,WACE,MAAO,CACLC,SAAUF,MAjBhB,iBAMA,CAAAb,KAACgB,EAAAA,SAADd,KAAA,CAAU,CACRe,QAAS,CACPC,EAAAA,aACAC,EAAAA,aAEFC,aAAc,CAACxG,GACfyG,QAAS,CAACzG"
}
